/**
 * Casus Belli Integration Layer
 *
 * Integrates the Casus Belli system with existing game systems:
 * - Grievances and Claims
 * - Trust and Relationships
 * - International Council
 * - Leader Abilities
 * - AI Diplomacy
 */

import type { Nation, GameState } from '../types/game';
import type { CasusBelli, WarState, WarValidation } from '../types/casusBelli';
import type { Grievance, Claim } from '../types/grievancesAndClaims';
import type { CouncilResolution } from '../types/diplomacyPhase3';
import type { TrustRecord } from '../types/trustAndFavors';
import {
  generateAutomaticCasusBelli,
  validateWarDeclaration,
  expireCasusBelli,
} from './casusBelliUtils';
import { declareWar, getDefaultWarGoals } from './warDeclarationUtils';
import { updateTrustScore, adjustRelationshipScore } from './trustAndFavorsUtils';
import { createGrievance } from './grievancesAndClaimsUtils';

function toGrievanceArray(grievances: Nation['grievances']): Grievance[] {
  return Array.isArray(grievances) ? grievances : [];
}

function toClaimArray(claims: Nation['claims']): Claim[] {
  return Array.isArray(claims) ? claims : [];
}

/**
 * Update Casus Belli for all nations based on game state
 * Should be called each turn
 */
export function updateCasusBelliForAllNations(
  nations: Nation[],
  currentTurn: number
): Nation[] {
  return nations.map((nation) => {
    // Expire old Casus Belli
    const activeCBs = expireCasusBelli(nation.casusBelli || [], currentTurn);

    const grievances = toGrievanceArray(nation.grievances);
    const claims = toClaimArray(nation.claims);

    // Generate new Casus Belli based on grievances/claims
    const newCBs: CasusBelli[] = [];
    for (const otherNation of nations) {
      if (otherNation.id === nation.id) continue;

      const autoGeneratedCBs = generateAutomaticCasusBelli(
        nation,
        otherNation,
        grievances,
        claims,
        currentTurn
      );

      newCBs.push(...autoGeneratedCBs);
    }

    // Merge with existing CBs, avoiding duplicates
    const allCBs = [...activeCBs];
    for (const newCB of newCBs) {
      const exists = allCBs.some(
        (cb) =>
          cb.type === newCB.type && cb.againstNationId === newCB.againstNationId
      );
      if (!exists) {
        allCBs.push(newCB);
      }
    }

    return {
      ...nation,
      casusBelli: allCBs,
    };
  });
}

/**
 * Apply diplomatic penalties for unjustified war
 */
export function applyWarDiplomaticPenalties(
  attacker: Nation,
  defender: Nation,
  validation: WarValidation,
  allNations: Nation[],
  currentTurn: number
): {
  updatedAttacker: Nation;
  updatedDefender: Nation;
  updatedNations: Nation[];
  newGrievances: Grievance[];
} {
  const newGrievances: Grievance[] = [];

  // Update attacker's relationships
  let updatedAttacker = { ...attacker };
  let updatedDefender = { ...defender };

  // Apply relationship penalty to defender
  if (validation.diplomaticPenalty !== 0) {
    updatedAttacker = adjustRelationshipScore(
      updatedAttacker,
      defender.id,
      validation.diplomaticPenalty,
      `Unjustified war declaration`,
      currentTurn
    );
  }

  // Apply trust penalty to defender
  if (validation.trustPenalty !== 0) {
    updatedAttacker = updateTrustScore(
      updatedAttacker,
      defender.id,
      validation.trustPenalty,
      `Unjustified war declaration`,
      currentTurn
    );
  }

  // Third-party reactions: other nations react to unjustified wars
  const updatedNations = allNations.map((nation) => {
    if (nation.id === attacker.id || nation.id === defender.id) {
      return nation; // Don't update attacker/defender here
    }

    let updatedNation = { ...nation };

    // If war is unjustified, other nations lose trust/relationship with attacker
    if (validation.validity === 'invalid') {
      // Stronger penalty for closer allies of defender
      const defenderRelationship =
        nation.relationships?.[defender.id] || 0;
      const penaltyModifier =
        defenderRelationship > 50 ? 2 : defenderRelationship > 0 ? 1.5 : 1;

      updatedNation = adjustRelationshipScore(
        updatedNation,
        attacker.id,
        Math.floor(-15 * penaltyModifier),
        `Unjustified aggression against ${defender.name}`,
        currentTurn
      );

      updatedNation = updateTrustScore(
        updatedNation,
        attacker.id,
        Math.floor(-10 * penaltyModifier),
        `Unjustified aggression`,
        currentTurn
      );
    } else if (validation.validity === 'weak') {
      // Mild penalty for weak CB
      updatedNation = adjustRelationshipScore(
        updatedNation,
        attacker.id,
        -5,
        `Questionable war against ${defender.name}`,
        currentTurn
      );
    }

    return updatedNation;
  });

  return {
    updatedAttacker,
    updatedDefender,
    updatedNations,
    newGrievances,
  };
}

/**
 * Check if council should intervene in a war
 */
export function shouldCouncilIntervene(
  warState: WarState,
  attacker: Nation,
  defender: Nation,
  councilLegitimacy: number
): boolean {
  // Council intervenes if:
  // 1. War is unjustified (CB justification < 30)
  // 2. Council has high legitimacy (>60)
  // 3. Attacker is not a permanent member
  // 4. War has caused significant casualties or nuclear weapons used

  const cbJustification = attacker.casusBelli?.find(
    (cb) => cb.id === warState.casusBelliId
  )?.justification || 0;

  if (cbJustification < 30 && councilLegitimacy > 60) {
    return true;
  }

  // Check for war crimes or excessive force
  if (warState.attackerWarScore > 80 && warState.defenderWarScore < 20) {
    return true;
  }

  return false;
}

/**
 * Generate council resolution for war intervention
 */
export function generateCouncilWarIntervention(
  warState: WarState,
  attacker: Nation,
  defender: Nation
): Partial<CouncilResolution> {
  return {
    type: 'ceasefire',
    title: `Ceasefire Resolution: ${attacker.name} vs ${defender.name}`,
    description: `The Council calls for an immediate ceasefire between ${attacker.name} and ${defender.name} due to unjustified aggression.`,
    targetNationId: attacker.id,
    parameters: {
      duration: 10,
    },
  };
}

/**
 * Process war declaration with full integration
 */
export function processWarDeclaration(
  attacker: Nation,
  defender: Nation,
  casusBelli: CasusBelli,
  nations: Nation[],
  gameState: GameState,
  currentTurn: number
): {
  success: boolean;
  warState?: WarState;
  updatedAttacker: Nation;
  updatedDefender: Nation;
  updatedNations: Nation[];
  newGrievances: Grievance[];
  councilResolution?: Partial<CouncilResolution>;
  message: string;
} {
  // Validate war declaration
  const validation = validateWarDeclaration(
    attacker,
    defender,
    toGrievanceArray(attacker.grievances),
    toClaimArray(attacker.claims),
    attacker.casusBelli || [],
    undefined,
    currentTurn
  );

  if (!validation.canDeclareWar) {
    return {
      success: false,
      updatedAttacker: attacker,
      updatedDefender: defender,
      updatedNations: nations,
      newGrievances: [],
      message: `Cannot declare war: ${validation.blockers?.join(', ')}`,
    };
  }

  // Create war goals
  const warGoals = getDefaultWarGoals(
    casusBelli,
    attacker,
    defender,
    toClaimArray(attacker.claims)
  );

  // Declare war
  const { warState, updatedCasusBelli, newGrievances } = declareWar(
    attacker,
    defender,
    casusBelli,
    warGoals,
    currentTurn
  );

  // Apply diplomatic penalties
  const {
    updatedAttacker: attackerWithPenalties,
    updatedDefender: defenderWithPenalties,
    updatedNations: nationsWithPenalties,
  } = applyWarDiplomaticPenalties(
    attacker,
    defender,
    validation,
    nations,
    currentTurn
  );

  // Update attacker's Casus Belli list
  const finalAttacker = {
    ...attackerWithPenalties,
    casusBelli: attacker.casusBelli?.map((cb) =>
      cb.id === casusBelli.id ? updatedCasusBelli : cb
    ),
    activeWars: [...(attackerWithPenalties.activeWars || []), warState],
  };

  // Update defender's active wars
  const finalDefender = {
    ...defenderWithPenalties,
    activeWars: [...(defenderWithPenalties.activeWars || []), warState],
  };

  // Check if council should intervene
  let councilResolution: Partial<CouncilResolution> | undefined;
  const councilLegitimacy =
    gameState.diplomacyPhase3?.internationalCouncil?.legitimacy || 0;
  if (shouldCouncilIntervene(warState, attacker, defender, councilLegitimacy)) {
    councilResolution = generateCouncilWarIntervention(
      warState,
      attacker,
      defender
    );
  }

  let message = `${attacker.name} declares war on ${defender.name}`;
  if (validation.validity === 'valid') {
    message += ` with valid Casus Belli: ${casusBelli.type}`;
  } else if (validation.validity === 'weak') {
    message += ` with weak Casus Belli (diplomatic penalties applied)`;
  } else {
    message += ` without valid justification (severe diplomatic penalties applied)`;
  }

  return {
    success: true,
    warState,
    updatedAttacker: finalAttacker,
    updatedDefender: finalDefender,
    updatedNations: nationsWithPenalties,
    newGrievances,
    councilResolution,
    message,
  };
}

/**
 * Get war declaration summary for UI
 */
export function getWarDeclarationSummary(
  attacker: Nation,
  defender: Nation,
  currentTurn: number
): {
  canDeclare: boolean;
  validation: WarValidation;
  bestCasusBelli?: CasusBelli;
  recommendedAction: string;
} {
  const validation = validateWarDeclaration(
    attacker,
    defender,
    toGrievanceArray(attacker.grievances),
    toClaimArray(attacker.claims),
    attacker.casusBelli || [],
    undefined,
    currentTurn
  );

  const bestCB = validation.availableCasusBelli.reduce(
    (best, cb) => (cb.justification > (best?.justification || 0) ? cb : best),
    undefined as CasusBelli | undefined
  );

  let recommendedAction = '';
  if (!validation.canDeclareWar) {
    recommendedAction = `Cannot declare war: ${validation.blockers?.join(', ')}`;
  } else if (validation.validity === 'valid') {
    recommendedAction = `War can be declared with valid justification`;
  } else if (validation.validity === 'weak') {
    recommendedAction = `War possible but with diplomatic penalties`;
  } else {
    recommendedAction = `War would incur severe diplomatic penalties - consider building claims or grievances first`;
  }

  return {
    canDeclare: validation.canDeclareWar,
    validation,
    bestCasusBelli: bestCB,
    recommendedAction,
  };
}

/**
 * Update war scores based on conventional warfare events
 */
export function syncConventionalWarfareToWarScore(
  warState: WarState,
  engagementSummary: {
    territoriesGained: number;
    majorVictories: number;
    minorVictories: number;
    armiesDestroyed: number;
  }
): WarState {
  let updatedWarState = { ...warState };

  // This would be called from conventional warfare hooks
  // to update war score based on military events

  return updatedWarState;
}

/**
 * Check all active wars and suggest peace for exhausted nations
 */
export function checkWarExhaustionForAllWars(
  nations: Nation[],
  allWars: WarState[],
  currentTurn: number
): {
  exhaustedNations: Array<{
    nationId: string;
    warId: string;
    shouldSeekPeace: boolean;
    exhaustionLevel: number;
  }>;
} {
  const exhaustedNations: Array<{
    nationId: string;
    warId: string;
    shouldSeekPeace: boolean;
    exhaustionLevel: number;
  }> = [];

  // Implementation would check each nation's wars
  // and calculate exhaustion based on war duration and score

  return { exhaustedNations };
}
